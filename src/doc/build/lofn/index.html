<!DOCTYPE HTML><html ><head ><title >Lofn</title><style >@import url(../rc/style.css);</style></head><body ><div id="contents"><div id="headarea"><h1>Lofn</h1>
<div class="pageinfo">Up: <a href="../index.html">index</a> · Last update: 2012-03-04</div></div><p>Lofn 是一种新型的、生成 JavaScript 的新语言。Lofn 拥有许多实用的特性，使得创作 JavaScript 更加容易。Lofn 编译器可以从  下载。Lofn 依赖 Eisa 运行时使得其生成的 JavaScript 得以运行，因此 Eisa 也是必要的。</p>
<h2>使用编译器</h2>
<pre >lfc &lt;options&gt; input.lf</pre><h3>选项</h3>
<ul><li><code>-o &lt;value&gt;</code>, <code>--output &lt;value&gt;</code>: 指定输出文件的路径。如果不指定，编译结果会显示在 Stdout 里。
</li>
<li><code>-t &lt;value&gt;</code>，<code>--target &lt;value&gt;</code>: 指定编译的目标环境，会影响默认的全局变量表。<code>-t least</code> 只会使用 <code>require</code>、<code>module</code> 和 <code>exports</code> 三个全局变量。
</li>
<li><code>-g &lt;value&gt;</code>，<code>--global &lt;value&gt;</code>: 指定一个全局变量，例如 <code>-g document</code>。
</li>
<li><code>-m &lt;name&gt;=&lt;path&gt;</code>，<code>--module &lt;name&gt;=&lt;path&gt;</code>: 将一个模块作为 Lofn 源码里的全局变量，如 <code>-m exp=express</code>，会将 <code>require('express')</code> 作为 Lofn 源码中的全局变量 <code>exp</code>。
</li>
</ul><h2>概要</h2>
<p>空白在 Lofn 中相当重要，例如，用于缩进的空白就表示源码的语法层次。这里没有 <code>end</code> 或者其他类似的东西，缩进一层，就表示一个新的语句块。使用 Tab 或者空格缩进都可以，但是在同一个文件里请不要随意更换。因为使用了缩进，Lofn 中的流程控制语句写法相当简单。通常，所有被控制的语句块都会以冒号开始，然后是缩进过的语句块。而如果冒号后没有换行，则表示只有一个语句受控。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">max</span><span class="punctor">(</span><span class="identifier">list</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword">var</span> <span class="identifier">m</span> <span class="operator">=</span> <span class="identifier">list</span><span class="punctor">[</span><span class="number literal">0</span><span class="punctor">]</span>
    <span class="keyword flowctrl">for</span> <span class="keyword">var</span> <span class="identifier">i</span> <span class="operator">in</span> <span class="number literal">0</span><span class="operator">..</span><span class="identifier">list</span><span class="punctor">.</span><span class="identifier">length</span><span class="punctor">:</span>
        <span class="keyword flowctrl">if</span> <span class="identifier">list</span><span class="punctor">[</span><span class="identifier">i</span><span class="punctor">]</span> <span class="operator">></span> <span class="identifier">m</span><span class="punctor">:</span> <span class="identifier">m</span> <span class="operator">=</span> <span class="identifier">list</span><span class="punctor">[</span><span class="identifier">i</span><span class="punctor">]</span>
    <span class="keyword flowctrl">return</span> <span class="identifier">m</span>
<span class="identifier">tracel</span> <span class="identifier">max</span> <span class="punctor">[</span><span class="number literal">5</span><span class="punctor">,</span> <span class="number literal">4</span><span class="punctor">,</span> <span class="number literal">3</span><span class="punctor">,</span> <span class="number literal">2</span><span class="punctor">,</span> <span class="number literal">1</span><span class="punctor">]</span></pre><p>Lofn 里一些换行会被视作空格，从而可以把一些很长的表达式分成两行写。这些换行通常是运算符前后、逗号后、<code>([{</code> 后以及 <code>}])</code> 前的换行。因此你可以利用他们来定义一些很复杂的对象。反斜线也可以让后面的换行化作一缕浮云，消失在编译器眼里。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">gameConfig</span> <span class="operator">=</span> <span class="punctor">[</span>
    <span class="identifier">player</span><span class="punctor">:</span> <span class="punctor">[</span>
        <span class="identifier">name</span><span class="punctor">:</span> <span class="string literal">"tom"</span><span class="punctor">,</span>
        <span class="identifier">type</span><span class="punctor">:</span> <span class="identifier">Human</span><span class="punctor">,</span>
        <span class="identifier">level</span><span class="punctor">:</span> <span class="number literal">1</span><span class="punctor">,</span>
        <span class="identifier">weapon</span><span class="punctor">:</span> <span class="identifier">sword</span><span class="punctor">,</span>
        <span class="identifier">inventory</span><span class="punctor">:</span> <span class="punctor">[</span><span class="identifier">food</span><span class="punctor">,</span> <span class="identifier">food</span><span class="punctor">,</span> <span class="identifier">potion</span><span class="punctor">,</span> <span class="identifier">bomb</span><span class="punctor">]</span>
    <span class="punctor">]</span><span class="punctor">,</span>
    <span class="identifier">enemy</span><span class="punctor">:</span> <span class="punctor">[</span>
        <span class="identifier">name</span><span class="punctor">:</span> <span class="string literal">"Dragon"</span><span class="punctor">,</span>
        <span class="identifier">type</span><span class="punctor">:</span> <span class="identifier">Dragon</span><span class="punctor">,</span>
        <span class="identifier">level</span><span class="punctor">:</span> <span class="number literal">9</span>
    <span class="punctor">]</span>
<span class="punctor">]</span></pre><pre class="mghl source lofn"><span class="comment">// some lisp code</span>
<span class="keyword">def</span> <span class="identifier">code</span> <span class="operator">=</span> <span class="punctor">[</span><span class="string literal">'define'</span><span class="punctor">,</span> <span class="punctor">[</span><span class="string literal">'fib'</span><span class="punctor">,</span> <span class="string literal">'n'</span><span class="punctor">]</span><span class="punctor">,</span>
    <span class="punctor">[</span><span class="string literal">'cond'</span><span class="punctor">,</span>
      <span class="punctor">[</span> <span class="punctor">[</span><span class="punctor">[</span><span class="string literal">'='</span><span class="punctor">,</span> <span class="string literal">'n'</span><span class="punctor">,</span> <span class="string literal">'1'</span><span class="punctor">]</span><span class="punctor">,</span> <span class="string literal">'1'</span><span class="punctor">]</span><span class="punctor">,</span>
        <span class="punctor">[</span><span class="punctor">[</span><span class="string literal">'='</span><span class="punctor">,</span> <span class="string literal">'n'</span><span class="punctor">,</span> <span class="string literal">'2'</span><span class="punctor">]</span><span class="punctor">,</span> <span class="string literal">'1'</span><span class="punctor">]</span><span class="punctor">,</span>
        <span class="punctor">[</span><span class="string literal">'()'</span><span class="punctor">,</span> 
            <span class="punctor">[</span><span class="string literal">'+'</span><span class="punctor">,</span> <span class="punctor">[</span><span class="string literal">'fib'</span><span class="punctor">,</span> <span class="punctor">[</span><span class="string literal">'-'</span><span class="punctor">,</span> <span class="string literal">'n'</span><span class="punctor">,</span> <span class="string literal">'1'</span><span class="punctor">]</span><span class="punctor">]</span><span class="punctor">,</span>
                <span class="punctor">[</span><span class="string literal">'fib'</span><span class="punctor">,</span> <span class="punctor">[</span><span class="string literal">'-'</span><span class="punctor">,</span> <span class="string literal">'n'</span><span class="punctor">,</span> <span class="string literal">'2'</span><span class="punctor">]</span><span class="punctor">]</span><span class="punctor">]</span><span class="punctor">]</span><span class="punctor">]</span><span class="punctor">]</span><span class="punctor">]</span></pre><p>从上面应该也能看出，Lofn 的注释用 <code>//</code> 开始到行尾结束。除了 <code>//</code>，使用 <code>--</code> 也是一样的。看到 <code>--</code> 可以开始注释，你应该就会明白 Lofn 里没有 <code>++</code> 和 <code>--</code> 运算符。除此之外，位于行首（之后不能有任何空白）的 <code>-!</code> 用于提供编译器选项，如「变量不声明就报错」就写作「<code>-! option explicit</code>」。</p>
<h2>变量（包括变不了的）</h2>
<p>Lofn 的变量用 <code>var</code> 或者 <code>def</code> 声明。<code>def</code> 声明出来的东西更接近常量，他们不能被再次赋值。在代码中，应当尽量使用 <code>def</code> 定义常量。他们典型的用法是这样：</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">printPrimes</span><span class="punctor">(</span><span class="identifier">uplimit</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword">def</span> <span class="identifier">primes</span> <span class="operator">=</span> <span class="punctor">[</span><span class="number literal">2</span><span class="punctor">,</span> <span class="number literal">3</span><span class="punctor">,</span> <span class="number literal">5</span><span class="punctor">,</span> <span class="number literal">7</span><span class="punctor">]</span><span class="punctor">;</span>
    <span class="keyword flowctrl">for</span> <span class="keyword">var</span> <span class="identifier">n</span> <span class="operator">in</span> <span class="number literal">2</span> <span class="operator">..</span><span class="punctor">.</span> <span class="identifier">uplimit</span><span class="punctor">:</span>
        <span class="keyword">var</span> <span class="identifier">composite</span> <span class="operator">=</span> <span class="literal">false</span>
        <span class="keyword flowctrl">for</span> <span class="punctor">(</span><span class="keyword">var</span> <span class="identifier">t</span> <span class="operator">=</span> <span class="number literal">0</span><span class="punctor">;</span> <span class="identifier">primes</span><span class="punctor">[</span><span class="identifier">t</span><span class="punctor">]</span> <span class="operator">*</span> <span class="identifier">primes</span><span class="punctor">[</span><span class="identifier">t</span><span class="punctor">]</span> <span class="operator">&lt;=</span> <span class="identifier">n</span><span class="punctor">;</span> <span class="identifier">t</span> <span class="operator">+=</span> <span class="number literal">1</span><span class="punctor">)</span><span class="punctor">:</span>
            <span class="keyword flowctrl">if</span> <span class="identifier">n</span> <span class="operator">%</span> <span class="identifier">primes</span><span class="punctor">[</span><span class="identifier">t</span><span class="punctor">]</span> <span class="operator">==</span> <span class="number literal">0</span><span class="punctor">:</span> 
                <span class="identifier">composite</span> <span class="operator">=</span> <span class="literal">true</span><span class="punctor">;</span>
                <span class="keyword flowctrl">break</span><span class="punctor">;</span>
        <span class="keyword flowctrl">if</span> <span class="operator">not</span> <span class="identifier">composite</span><span class="punctor">:</span>
            <span class="identifier">primes</span><span class="punctor">.</span><span class="identifier">push</span> <span class="identifier">n</span><span class="punctor">;</span>
            <span class="identifier">tracel</span> <span class="identifier">n</span><span class="punctor">;</span></pre><p>变量的作用域法则完全等同 JavaScript，使用 <code>var</code> 来「局域化」变量。这和一些生成 JavaScript 的语言不同，但是对于熟悉 JavaScript 的用户来说，这样很有用。</p>
<p><code>def</code> 只能来定义一个东西，而 <code>var</code> 一次可以声明多个变量（方法：<code>var a, b, c, d, ..., z</code>，不能赋值）。<code>def</code> 和 <code>var</code> 也可用于定义对象的属性，这只相当于是一次简单赋值。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">Number</span><span class="punctor">.</span><span class="identifier">prototype</span><span class="punctor">.</span><span class="identifier">times</span> <span class="operator">=</span> <span class="keyword function">function</span><span class="punctor">(</span><span class="identifier">f</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword flowctrl">for</span> <span class="keyword">var</span> <span class="identifier">i</span> <span class="operator">in</span> <span class="number literal">0</span><span class="operator">..</span><span class="keyword">this</span><span class="punctor">:</span> <span class="identifier">f</span><span class="punctor">(</span><span class="identifier">i</span><span class="punctor">)</span></pre><h2>函数</h2>
<p>最好用（以及最推荐）的方法是使用 <code>def</code> 定义函数。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">square</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">x</span> <span class="operator">*</span> <span class="identifier">x</span>   <span class="comment">// 简单的函数可以这样定义</span>

<span class="keyword">def</span> <span class="identifier">fill</span><span class="punctor">(</span><span class="identifier">container</span><span class="punctor">,</span> <span class="identifier">liquid</span> <span class="operator">=</span> <span class="string literal">"water"</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="comment">// 使用冒号不生成 return</span>
    <span class="identifier">tracel</span> <span class="string literal">"Fill "</span> <span class="operator">+</span> <span class="identifier">container</span> <span class="operator">+</span> <span class="string literal">" with "</span> <span class="operator">+</span> <span class="identifier">liquid</span>

<span class="comment">// Y 组合子</span>
<span class="keyword">def</span> <span class="identifier">Y</span><span class="punctor">(</span><span class="identifier">g</span><span class="punctor">)</span> <span class="operator">=</span> <span class="comment">// 在这里使用等号……</span>
    <span class="keyword">def</span> <span class="identifier">rec</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">)</span><span class="punctor">(</span><span class="identifier">y</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">g</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">)</span><span class="punctor">)</span><span class="punctor">(</span><span class="identifier">y</span><span class="punctor">)</span>
    <span class="identifier">rec</span><span class="punctor">(</span><span class="identifier">rec</span><span class="punctor">)</span> <span class="comment">// 就会在这里自动产生 return 语句</span>

<span class="comment">//def FixedCombinator(g)(x) = g(Y(g))(x)</span>

<span class="comment">// 使用 Y 组合子定义「递归」函数</span>
<span class="keyword">def</span> <span class="identifier">Y</span> <span class="identifier">fibonacci</span><span class="punctor">(</span><span class="identifier">recurse</span><span class="punctor">)</span><span class="punctor">(</span><span class="identifier">n</span><span class="punctor">)</span> <span class="operator">=</span> <span class="comment">// 多个参数表表示柯里化</span>
    <span class="keyword flowctrl">if</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">&lt;=</span> <span class="number literal">2</span><span class="punctor">)</span><span class="punctor">:</span> <span class="number literal">1</span>
    <span class="keyword flowctrl">else</span><span class="punctor">:</span> <span class="identifier">recurse</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">-</span> <span class="number literal">2</span><span class="punctor">)</span> <span class="operator">+</span> <span class="identifier">recurse</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">-</span> <span class="number literal">1</span><span class="punctor">)</span>

<span class="identifier">fibonacci</span><span class="punctor">(</span><span class="number literal">5</span><span class="punctor">)</span> <span class="comment">// 5</span></pre><p>使用 <code>def</code> 定义函数应写下 <code>def</code>、你想定义的函数名、参数表，然后是 <code>:</code> 或者 <code>=</code>。在使用 <code>:</code> 的时候，你必须自己写 <code>return</code> 语句来指明返回值；使用 <code>=</code> 则不必要，编译器会自动把这个函数里最后一个表达式语句作为返回值。</p>
<p>值得注意的是最后一个使用 Y 组合子制造递归函数的案例。在此处，<code>Y</code> 将后面的函数进行处理后赋值给 <code>fibonacci</code>；这里的 <code>Y</code> 只是一个普通函数，在上面定义出来。这些修饰很像 Python 里的那些。然而，使用修饰时，函数的签名可能会发生变化，增加代码的复杂性，因此在这种情况发生的时候，建议增加注释说明。在上面那个案例里，实际上发生的赋值是这样的：</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">fibonacci_1</span> <span class="operator">=</span> <span class="keyword function">function</span><span class="punctor">(</span><span class="identifier">recurse</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword flowctrl">return</span> <span class="keyword function">function</span><span class="punctor">(</span><span class="identifier">n</span><span class="punctor">)</span><span class="punctor">:</span>
        <span class="keyword flowctrl">return</span> <span class="number literal">1</span> <span class="keyword flowctrl">if</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">&lt;=</span> <span class="number literal">2</span><span class="punctor">)</span><span class="punctor">,</span>
            <span class="identifier">recurse</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">-</span> <span class="number literal">2</span><span class="punctor">)</span> <span class="operator">+</span> <span class="identifier">recurse</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">-</span> <span class="number literal">1</span><span class="punctor">)</span>
<span class="keyword">def</span> <span class="identifier">fibonacci</span> <span class="operator">=</span> <span class="identifier">Y</span><span class="punctor">(</span><span class="identifier">fibonacci_1</span><span class="punctor">)</span></pre><p>这里出现了新的关键字 <code>function</code> 以及用它定义的匿名函数。匿名函数在 JavaScript 里很常见，在 Lofn 中，定义一个匿名函数值的方法相当多，最直接的就是用 <code>function</code> 关键字换掉 <code>def</code> 里写下的函数名。类似 <code>def</code> 里的情况，<code>function（...)</code> 之后也可以跟 <code>:</code> 和 <code>=</code>，两者的区别仍然是，「<code>=</code>」会自动产生 <code>return</code>，「<code>:</code>」不会。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">fibonacci_2</span> <span class="operator">=</span> <span class="keyword function">function</span><span class="punctor">(</span><span class="identifier">recurse</span><span class="punctor">)</span><span class="operator">=</span>
    <span class="keyword function">function</span><span class="punctor">(</span><span class="identifier">n</span><span class="punctor">)</span><span class="operator">=</span>
        <span class="number literal">1</span> <span class="keyword flowctrl">if</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">&lt;=</span> <span class="number literal">2</span><span class="punctor">)</span><span class="punctor">,</span>
            <span class="identifier">recurse</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">-</span> <span class="number literal">2</span><span class="punctor">)</span> <span class="operator">+</span> <span class="identifier">recurse</span><span class="punctor">(</span><span class="identifier">n</span> <span class="operator">-</span> <span class="number literal">1</span><span class="punctor">)</span></pre><p>另一种方法是使用 <code>:&gt;</code> 或 <code>=&gt;</code>，构造 Lambda 表达式，前接参数表，后接函数体。规律和 <code>function</code> 里的用法很相似，<code>:&gt;</code> 必须手工写入 <code>return</code> 语句，<code>=&gt;</code> 会自动生成 <code>return</code>。<code>=&gt;</code> 经常用于定义一些小函数。</p>
<pre class="mghl source lofn"><span class="identifier">list</span><span class="punctor">.</span><span class="identifier">map</span> <span class="punctor">(</span><span class="identifier">term</span><span class="punctor">,</span> <span class="identifier">index</span><span class="punctor">)</span> <span class="punctor">=></span> <span class="identifier">term</span> <span class="operator">*</span> <span class="identifier">index</span>
<span class="identifier">$</span><span class="punctor">(</span><span class="identifier">element</span><span class="punctor">)</span><span class="punctor">.</span><span class="identifier">bind</span> <span class="string literal">"click"</span><span class="punctor">,</span> <span class="punctor">(</span><span class="identifier">event</span><span class="punctor">)</span> <span class="operator">:></span>
    <span class="identifier">tracel</span> <span class="identifier">event</span></pre><p>Lambda 表达式的右端会尽可能的长。当然，如果出现像下面的这种情况，您的代码已经很难读懂，应当加入括弧来使之清晰。</p>
<pre class="mghl source lofn"><span class="identifier">f</span> <span class="punctor">(</span><span class="identifier">x</span><span class="punctor">)</span> <span class="operator">:></span> <span class="identifier">g</span> <span class="identifier">x</span><span class="punctor">,</span> <span class="number literal">1</span>
<span class="comment">// 等价于</span>
<span class="identifier">f</span> <span class="punctor">(</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">)</span> <span class="operator">:></span> <span class="identifier">g</span> <span class="identifier">x</span><span class="punctor">,</span> <span class="number literal">1</span><span class="punctor">)</span><span class="punctor">,</span></pre><p>Lambda 表达式的 <code>:&gt;</code> 和 <code>=&gt;</code> 也可以没有参数表，作用和 <code>():&gt;</code> 相同。使用回调的时候这种形式会很管用。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">sleep</span><span class="punctor">(</span><span class="identifier">dt</span><span class="punctor">,</span> <span class="identifier">f</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">setTimeout</span><span class="punctor">(</span><span class="identifier">f</span><span class="punctor">,</span> <span class="identifier">dt</span><span class="punctor">)</span>
<span class="identifier">sleep</span> <span class="number literal">1000</span><span class="punctor">,</span> <span class="operator">:></span>
    <span class="identifier">tracel</span> <span class="string literal">'Blah!'</span></pre><p>最后一种形式是用花括弧包裹住表达式，这在 DSL 里这会很常见。表达式的值就是此函数的返回值。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">repeatWhile</span><span class="punctor">(</span><span class="identifier">condition</span><span class="punctor">,</span> <span class="identifier">body</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword">var</span> <span class="identifier">c</span>
    <span class="keyword flowctrl">while</span><span class="punctor">(</span><span class="identifier">c</span> <span class="operator">=</span> <span class="identifier">condition</span><span class="punctor">(</span><span class="punctor">)</span><span class="punctor">)</span><span class="punctor">:</span>
        <span class="identifier">body</span><span class="punctor">(</span><span class="identifier">c</span><span class="punctor">)</span>

<span class="keyword">var</span> <span class="identifier">num</span> <span class="operator">=</span> <span class="number literal">10</span><span class="punctor">;</span>
<span class="identifier">repeatWhile</span> <span class="punctor">{</span><span class="identifier">num</span> <span class="operator">-=</span> <span class="number literal">1</span><span class="punctor">}</span><span class="punctor">,</span> <span class="punctor">{</span><span class="operator">|</span><span class="identifier">j</span><span class="operator">|</span> <span class="identifier">tracel</span> <span class="identifier">j</span><span class="punctor">}</span></pre><h2>调用函数</h2>
<p>调用函数最直接的方法是使用圆括号，圆括号和之前的被调用函数之间不能有空白：</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">f</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">,</span> <span class="identifier">y</span><span class="punctor">,</span> <span class="identifier">z</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">x</span> <span class="operator">*</span> <span class="identifier">y</span> <span class="operator">+</span> <span class="identifier">z</span>
<span class="identifier">f</span><span class="punctor">(</span><span class="number literal">1</span><span class="punctor">,</span> <span class="number literal">1</span><span class="punctor">,</span> <span class="number literal">1</span><span class="punctor">)</span> <span class="comment">// 2</span></pre><p>可以使用名称参数。名称参数会汇聚起来，作为函数的最后一个实参传入。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">f</span><span class="punctor">(</span><span class="identifier">config</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">config</span><span class="punctor">.</span><span class="identifier">a</span> <span class="operator">+</span> <span class="identifier">config</span><span class="punctor">.</span><span class="identifier">b</span>
<span class="identifier">f</span><span class="punctor">(</span><span class="identifier">a</span><span class="punctor">:</span> <span class="number literal">1</span><span class="punctor">,</span> <span class="identifier">b</span><span class="punctor">:</span> <span class="number literal">2</span><span class="punctor">)</span> <span class="comment">// 3</span></pre><p>在不混淆时，可以省略括弧。不过，不建议省略太多层的括号。</p>
<pre class="mghl source lofn"><span class="identifier">f</span> <span class="identifier">g</span> <span class="identifier">h</span> <span class="identifier">a</span><span class="punctor">,</span> <span class="identifier">b</span><span class="punctor">,</span> <span class="identifier">c</span>
<span class="comment">// 等价于</span>
<span class="identifier">f</span><span class="punctor">(</span><span class="identifier">g</span><span class="punctor">(</span><span class="identifier">h</span><span class="punctor">(</span><span class="identifier">a</span><span class="punctor">,</span> <span class="identifier">b</span><span class="punctor">,</span> <span class="identifier">c</span><span class="punctor">)</span><span class="punctor">)</span><span class="punctor">)</span></pre><p>如果调用的实参表只有一项而且是使用 <code>{}</code> 的函数直接量时，可以用花括弧直接替换圆括弧：</p>
<pre class="mghl source lofn"><span class="identifier">act</span><span class="punctor">{</span><span class="identifier">tracel</span> <span class="string literal">'Acted!'</span><span class="punctor">}</span></pre><p>Lofn 支持一种特殊的方法来调用函数。通过使用 <code>|</code> 符号。在此符号后写上函数也表示函数调用，竖线之前者作为此次调用的第一个参数传入。您还可以追加更多的参数，写在后面。<code>|</code> 可以有很多个，串成一长串。在计算的时候，竖线之前的东西会先计算，之后才是写在竖线后的函数，因而在最终编译生成的 JavaScript 里，可能会有临时变量和赋值出现。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">tap</span><span class="punctor">(</span><span class="identifier">value</span><span class="punctor">,</span> <span class="identifier">f</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">f</span><span class="punctor">(</span><span class="identifier">value</span><span class="punctor">)</span> <span class="keyword">then</span> <span class="identifier">value</span><span class="punctor">;</span>
<span class="number literal">5</span> <span class="operator">|</span><span class="identifier">tap</span> <span class="punctor">{</span><span class="operator">|</span><span class="identifier">x</span><span class="operator">|</span> <span class="identifier">tracel</span> <span class="identifier">x</span><span class="punctor">}</span> <span class="operator">|</span><span class="punctor">{</span><span class="operator">|</span><span class="identifier">x</span><span class="operator">|</span> <span class="identifier">x</span> <span class="operator">*</span> <span class="number literal">3</span><span class="punctor">}</span> <span class="comment">// 5</span>
  <span class="operator">|</span><span class="identifier">tap</span> <span class="punctor">{</span><span class="operator">|</span><span class="identifier">x</span><span class="operator">|</span> <span class="identifier">tracel</span> <span class="identifier">x</span><span class="punctor">}</span>              <span class="comment">// 15</span></pre><p>JavaScript 里很常用的「链式调用」使用一个略微不同的符号 <code>|.</code>，之后接方法名。</p>
<pre class="mghl source lofn"><span class="identifier">$</span> <span class="string literal">"selector"</span>
    <span class="operator">|</span><span class="punctor">.</span><span class="identifier">addClass</span> <span class="string literal">"selected"</span>
    <span class="operator">|</span><span class="punctor">.</span><span class="identifier">css</span> <span class="identifier">background</span><span class="punctor">:</span> <span class="string literal">"red"</span></pre><p>两种“管道调用”可以任意组合。</p>
<h3>伪函数</h3>
<p>Lofn 中有几个关键字可以像函数那样「调用」，不过它们实际上作用于编译期，用来生成特殊的代码。它们是 <code>new</code>、<code>resend</code>、<code>do</code> 和 <code>wait</code>。它们称为伪函数。所有的伪函数都只能接受一个非命名参数（否则报语法错），不能单独出现（否则照样语法错）。一些伪函数还限制它们接受的「参数」必须拥有函数调用的形式，这样的伪函数也可以叫做调用修饰。</p>
<p><code>new</code> 用来构造对象：</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">Point</span><span class="punctor">(</span><span class="identifier">x</span><span class="punctor">,</span> <span class="identifier">y</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword">this</span><span class="punctor">.</span><span class="identifier">x</span> <span class="operator">=</span> <span class="identifier">x</span>
    <span class="keyword">this</span><span class="punctor">.</span><span class="identifier">y</span> <span class="operator">=</span> <span class="identifier">y</span>

<span class="keyword">def</span> <span class="identifier">origin</span> <span class="operator">=</span> <span class="identifier">new</span> <span class="identifier">Point</span> <span class="number literal">0</span><span class="punctor">,</span> <span class="number literal">0</span></pre><p><code>resend</code> 用来向其他函数封送 <code>this</code>。在面向对象编程里，常用于调用「基类」的方法。它后面必须接一个函数调用。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">Man</span><span class="punctor">(</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="comment">//...</span>
<span class="keyword">def</span> <span class="identifier">Man</span><span class="punctor">:</span><span class="punctor">:</span><span class="identifier">speak</span><span class="punctor">(</span><span class="identifier">something</span><span class="punctor">)</span> <span class="operator">=</span> <span class="identifier">tracel</span> <span class="identifier">something</span><span class="punctor">;</span>

<span class="keyword">def</span> <span class="identifier">outof</span><span class="punctor">(</span><span class="identifier">Man</span><span class="punctor">)</span> <span class="identifier">Child</span><span class="punctor">(</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="comment">//...</span>
<span class="keyword">def</span> <span class="identifier">Child</span><span class="punctor">:</span><span class="punctor">:</span><span class="identifier">speak</span><span class="punctor">(</span><span class="identifier">something</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="identifier">tracel</span> <span class="string literal">"Ah!"</span><span class="punctor">;</span>
    <span class="identifier">tracel</span> <span class="identifier">resend</span> <span class="identifier">Man</span><span class="punctor">:</span><span class="punctor">:</span><span class="identifier">speak</span><span class="punctor">(</span><span class="identifier">something</span><span class="punctor">)</span>
    <span class="comment">// 等价于 tracel Man.prototype.speak.call(this, something)</span></pre><p><code>do</code> 的行为和 <code>resend</code> 很相似。<code>do</code> 后接函数调用时的行为同 <code>resend</code> 一致，但是 <code>do</code> 后面还可以接其他形式的表达式，此时 <code>do f</code> 相当于 <code>f.apply(this, arguments)</code>。</p>
<p><code>wait</code> 用于生成回调。如果某个函数里出现了 <code>wait</code>，这个函数里的所有代码生成都会受到影响，甚至它本身也会变成其他类型。<code>wait</code> 常用于异步操作中。<code>wait</code> 后面也必须接一个函数调用。</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">f</span><span class="punctor">(</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="comment">// 不需要书写 loadResource something, function(resource)...</span>
    <span class="keyword">var</span> <span class="identifier">resource</span> <span class="operator">=</span> <span class="identifier">wait</span> <span class="identifier">loadResource</span><span class="punctor">(</span><span class="identifier">something</span><span class="punctor">)</span>
<span class="identifier">tracel</span> <span class="punctor">(</span><span class="identifier">type</span> <span class="identifier">of</span> <span class="identifier">f</span><span class="punctor">)</span> <span class="comment">// "object"，此时 f 是一个阻塞原语（见下文），并非普通函数。</span></pre><p><code>wait</code> 有一种等价的形式，是把 <code>!</code> 插在函数和调用函数用的括弧之间，如 <code>loadResource!(something)</code>。</p>
<h2>回调和阻塞</h2>
<p>前文已经述及，<code>wait</code> 所在的函数会变成阻塞原语。阻塞原语是一个对象，结构大致是这样：</p>
<pre class="mghl source lofn"><span class="comment">// 这样的定义……</span>
<span class="keyword">def</span> <span class="identifier">obstructive</span><span class="punctor">(</span><span class="identifier">args</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="comment">//... wait f() ...</span>
    <span class="comment">//... f!() ...</span>
<span class="comment">// 形成这样的对象</span>
<span class="punctor">[</span><span class="identifier">build</span><span class="punctor">:</span> <span class="keyword function">function</span><span class="punctor">(</span><span class="identifier">schemata</span><span class="punctor">)</span><span class="punctor">(</span><span class="identifier">args</span><span class="punctor">)</span><span class="punctor">(</span><span class="punctor">)</span><span class="punctor">]</span></pre><p><code>schemata</code> 是一个对象，定义了一组方法（<code>break</code> 和 <code>return</code>，以后可能还会增加 <code>error</code>）来处理阻塞原语的返回值，区分阻塞原语因为阻塞返回还是真正的返回。在迭代器里，就需要区分两种情形并且对返回值进行不同的处理。（或者说区分 yield 和 return）。<code>args</code> 就是在定义时定义的传入的参数表。第三个括弧则用来启动这个阻塞原语。</p>
<p>通常用来定义阻塞原语的 <code>def</code> 后面都会跟些东西修饰编译生成的「裸」原语，比如 <code>eisa/libs/async</code> 提供的 <code>async</code> 就可以处理绝大多数 JavaScript 库里面的回调：</p>
<pre class="mghl source lofn"><span class="keyword">def</span> <span class="identifier">async</span> <span class="identifier">randPrintNums</span><span class="punctor">(</span><span class="identifier">n</span><span class="punctor">)</span><span class="punctor">:</span>
    <span class="keyword">def</span> <span class="identifier">tasks</span> <span class="operator">=</span> <span class="punctor">[</span><span class="punctor">]</span><span class="punctor">;</span>
    <span class="keyword flowctrl">for</span> <span class="keyword">var</span> <span class="identifier">i</span> <span class="operator">in</span> <span class="number literal">0</span><span class="operator">..</span><span class="identifier">n</span><span class="punctor">:</span>
        <span class="identifier">tasks</span><span class="punctor">.</span><span class="identifier">push</span> <span class="identifier">let</span><span class="punctor">(</span><span class="identifier">i</span><span class="punctor">)</span> <span class="punctor">=></span> <span class="identifier">async</span> <span class="operator">:></span>
            <span class="identifier">wait</span> <span class="identifier">sleep</span> <span class="number literal">100</span> <span class="operator">*</span> <span class="identifier">Math</span><span class="punctor">.</span><span class="identifier">random</span><span class="punctor">(</span><span class="punctor">)</span>
            <span class="identifier">tracel</span> <span class="identifier">i</span>
    <span class="identifier">wait</span> <span class="identifier">join</span> <span class="identifier">tasks</span></pre><p>值得注意的是第三个例子，使用了嵌套的 <code>async</code>。</p>
</div></body></html>