::document{moescript}

**Moe is a new, not-very-little light Javascript-targeted language written in JavaScript.** 

You can get it from \githubProject.

:section{`Moec` compiler}
	:pre
		moec <options> input.moe
	:section{Options}	
		 - `-o <value>`, `--output <value>`: Specify the path of output file. If it is not specified, `moec` will print generated code into STDOUT.
		 - `-t <value>`，`--target <value>`: Specify the compilation target which affects global variable list. `-t least` will provide `require`、`module` and `exports` only for globals. `-t node` will provide all Node global variables.
		 - `-g <value>`，`--global <value>`: Specify a global variable, e.g. `-g document`。
		 - `-m <name>=<path>`，`--module <name>=<path>`: Map a module into a global variable, for exmaple, `-m exp=express` will map `require('express')` into the global variablr `exp` inside Moe source.

:section{Moe loader}
	The `moeDummy` makes Node possible to load `.moe` files as well as `.js`. Everything required is
	:*js
		require('moe/dummy')

:section{Overview}
	First, whitespaces plays important rule in Moe, indents means structure for example. There is nothing works like `end` or `{}` in other languages. It is not required to use `;` to terminate statements (though semiclolns still works as well), and use indentation instead of surrounding statements with `{}`. Every control block is started by a symbol like `:`, `=>` or `=`, then one **unindented** statement, or a indented statement block.
	:*moe
		def max(list):
			var m = list[0]
			for var i in 0..list.length:
				if list[i] > m: m = list[i]
			return m
		tracel max [5, 4, 3, 2, 1]

	Newlines **around** some symbols will be ignored so that you could write long expressions or complex literals. Unlike Python, line breaks inside parentheses, which often causes syntax errors, will not be ignored.
	:*moe
		tracel \
			1,
			2,
			3 +
			 4
			 + 5

		-- A game congi
		def gameConfig = [
			player: [
				name: "tom",
				type: Human,
				level: 1,
				weapon: sword,
				inventory: [food, food, potion, bomb]
			],
			enemy: [
				name: "Dragon",
				type: Dragon,
				level: 9
			]
		]

		// some lisp code
		def code = ['define', ['fib', 'n'],
			['cond',
			  [ [['=', 'n', '1'], '1'],
				[['=', 'n', '2'], '1'],
				['()', 
					['+', ['fib', ['-', 'n', '1']],
						['fib', ['-', 'n', '2']]]]]]]
	:*moe
		-- Wrong example: newline inside parentheses
		--	(tracel  -- here
		--		x,
		--		y,
		--		z)

:section{Variables (and immutable ones)}
	Variables in Moe is defined by `var` or `def`. "Variables" defined by `def` is actually a constant, which means it is impossible make any assignment to it. Scopes rule is exactly same as JavaScript, `var` and `def` **shadows** external variables.
	:*moe
		var outer = 1
		var x = 2
		def f = function():
			var inner = 3
			outer = 4
			var x = 5
			tracel inner  -- 3
			tracel outer  -- 4
			tracel x      -- 5
		f()
		tracel outer      -- 4
		tracel x          -- 2

	`def` can only define one thing once, with `var` can declares multiple variables without initialization. However, you are able to use `def` for defining properties, which is useful processing objects. In this situation, `def` is only a simple assignment.
	:*moe
		def Number.prototype.times = function(f):
			for var i in 0..this: f(i)

:section{Functions}
	The most recommended way to define a function is using `def`. Add argument list after the function name, then a `:` or `=`, then the function body.

	Function bodies started by `=` will **generate `return` statements automatically**, means its last expression executed will become its return value. Therefore, it is not required to use `return` statements. On the contraty, `:`-bodies won't. You must use `return` statements explicitly to specify its return value, or the function will simply return `undefined`, like what JavaScript acts.

	Functions may also have default values for arguments. Override the default value by passing an argument.

	:*moe
		// Define a simple function
		-- function square: calculate square of a number
		-- square(x <- Number) <- Number
		def square(x) = x * x

		// A procedure.
		-- function printPrimes: print all prime numbers not greater than an uplimit specified
		-- printPrimes(uplimit <- Number)
		def printPrimes(uplimit):
			def primes = [2, 3, 5, 7];
			for var n in 2 ... uplimit:
				var composite = false
				for (var t = 0; primes[t] * primes[t] <= n; t += 1):
					if n % primes[t] == 0: 
						composite = true;
						break;
				if not composite:
					primes.push n;
					tracel n;

		// Parameters with default value
		def fill(container, liquid = "water"):
			tracel ("Fill " + container + " with " + liquid)

		-- function Y: Fixed point combinator
		-- Y(g <- Function) <- Function
		--     which Y(g)(x) = g(Y(g))(x)
		def Y(g) =
			// use "=" here...
			def rec(x)(y) = g(x(x)) y
			rec(rec) // ...means this value will be returned.
		
		// Define recursive function using Y
		def Y fibonacci(recurse)(n) =
			// Multiple argument lists means currying
			if(n <= 2): 1
			else: recurse(n - 2) + recurse(n - 1)
		
		fibonacci(5) // 5
	
	There is a notable example using the `Y` combinator. Expressions like `Y` after `def` is a **modifer**, which is useful in defining wrapped functions, for example, recursive functions produced by `Y`. Here, `fibonacci` is actually:
	:*moe
		def fibonacci_1 = function(recurse):
			return function(n):
				return 1 if(n <= 2),
					recurse(n - 2) + recurse(n - 1)
		def fibonacci = Y(fibonacci_1)
	
	No-name functions can be defined using `function`. Like what we did in `def`, you can simply replace that function name by `function`. In the same matter, `=` for automatic generated `return`s, `:` for manual.
	:*moe
		def fibonacci_2 = function(recurse)=
			function(n)=
				1 if(n <= 2),
					recurse(n - 2) + recurse(n - 1)
	
	Another way, called **Lambdas**, is using an optional list of parameters, an arrow(`:>` or `=>`), and the function body. Unindented Lambdas will extend all the way to the right as long aspossible. The `=`-`:` rule still rules here.
	:*moe
		list.map (term, index) => term * index
		$(element).bind "click", (event) :>
			tracel event

		def sleep(dt, f) = setTimeout(f, dt)
		sleep 1000, :>
			tracel 'Blah!'
		// Note: different from (act) :> something
		act :> something
	
	The final form is wrapping **one** expression using `{}`. The wrapped expression will be the return value. Arguments are writtern inside the brackets, and wrapped by `|`'s. This is called **Delaied expression**.
	:*moe
		def repeatWhile(condition, body):
			var c
			while(c = condition()):
				body(c)

		var num = 10;
		repeatWhile {num -= 1}, {|j| tracel j}

:section{Objects}
	Both object literals and array literals uses `[]`. Therefore, empty objects should use `[:]` while `[]` means empty array. Keywords can appear inside object literals without quoting.
	:*moe
		def actions = [
			if: ((cond, fThen, fElse) => fThen() if(cond), fElse())
		]

	You can also use `object` function provided in standard libary for large objects, especially configs.
	:*moe
		-- function object: creates object using a constructor with an optional prototype.
		-- object(oPrototype, fConstruct) <- Derives(oPrototype)
		-- object(fConstruct) <- Object

		def gameConfig = object =>
		    @player = object =>
		        @name = "tom"
		        @type = Human
		        @level = 1
		        @weapon = sword
		        @inventory = [food, food, potion, bomb]
		    @enemy = object =>
		        @name = "Dragon"
		        @type = Dragon
		        @level = 9

:section{Calling functions}
	The most direct way to call a function is using brackets(`()`). Note that there **must not** be any space between the function and the brackets. If there is only one argument, and it is a delaied expression (`{expr}`), the `()` can be omitted.
	:*moe
		def f(x, y, z) = x * y + z
		f(1, 1, 1) // 2

		def act(f) = f()
		act{tracel 'blah!'} // short for act({tracel 'blah!'})
	
	You can use named arguments. All named arguments will be accumulated into an object literal passed into the function as the last argument.
	:*moe
		def f(config) = config.a + config.b
		f(a: 1, b: 2) // 3
	
	在不混淆时，可以省略括弧，下面是一些案例。
	:*moe
		f g h a, b, c
		x y z w
		f
	分别等价于
	:*moe
		f(g(h(a, b, c)))
		x(y(z(w)))
		f  // 不产生调用
	Moe 支持的省略调用只能有「`f g h a, b, c`」这样的形式，而且省略调用和运算符不能混用（因此 `f + g h` 会产生语法错）。
	
	Moe 支持一种特殊的方法来调用函数。通过使用 `|` 符号。在此符号后写上函数也表示函数调用，竖线之前者作为此次调用的第一个参数传入。您还可以追加更多的参数，写在后面。`|` 可以有很多个，串成一长串。在计算的时候，竖线之前的东西会先计算，之后才是写在竖线后的函数，因而在最终编译生成的 JavaScript 里，可能会有临时变量和赋值出现。
	:*moe
		def tap(value, f) = f(value) then value;
		5 |tap {|x| tracel x} |{|x| x * 3} // 5
		  |tap {|x| tracel x}              // 15
		 
	JavaScript 里很常用的「链式调用」使用一个略微不同的符号 `|.`，之后接方法名。
	:*moe
		$ "selector"
			|.addClass "selected"
			|.css background: "red"
	
	两种“管道调用”可以任意组合。

	:section{伪函数}
		Moe 中有几个关键字可以像函数那样「调用」，不过它们实际上作用于编译期，用来生成特殊的代码。它们是 `new`、`resend`、`do` 和 `wait`。它们称为伪函数。所有的伪函数都只能接受一个非命名参数（否则报语法错），不能单独出现（否则照样语法错）。一些伪函数还限制它们接受的「参数」必须拥有函数调用的形式，这样的伪函数也可以叫做调用修饰。

		`new` 用来构造对象：
		:*moe
			def Point(x, y):
				this.x = x
				this.y = y

			def origin = new Point 0, 0
		
		`resend` 用来向其他函数封送 `this`。在面向对象编程里，常用于调用「基类」的方法。它后面必须接一个函数调用。
		:*moe
			def Man():
				//...
			def Man::speak(something) = tracel something;

			def outof(Man) Child():
				//...
			def Child::speak(something):
				tracel "Ah!";
				tracel resend Man::speak(something)
				// 等价于 tracel Man.prototype.speak.call(this, something)
		`do` 的行为和 `resend` 很相似。`do` 后接函数调用时的行为同 `resend` 一致，但是 `do` 后面还可以接其他形式的表达式，此时 `do f` 相当于 `f.apply(this, arguments)`。

		`wait` 用于生成回调。如果某个函数里出现了 `wait`，这个函数里的所有代码生成都会受到影响，甚至它本身也会变成其他类型。`wait` 常用于异步操作中。`wait` 后面也必须接一个函数调用。
		:*moe
			def f():
				// 不需要书写 loadResource something, function(resource)...
				var resource = wait loadResource(something)
			tracel (type of f) // "object"，此时 f 是一个阻塞原语（见下文），并非普通函数。

		`wait` 有一种等价的形式，是把 `!` 插在被调用的函数之后，**之前不能有空白**，如 `loadResource! something`。

:section{回调和阻塞}
	前文已经述及，`wait` 所在的函数会变成阻塞原语。阻塞原语是一个对象，结构大致是这样：
	:*moe
		// 这样的定义……
		def obstructive(args):
			//... wait f() ...
			//... f!() ...
		// 形成这样的对象
		[build: function(schemata)(args)()]
	
	`schemata` 是一个对象，定义了一组方法（`break` 和 `return`，以后可能还会增加 `error`）来处理阻塞原语的返回值，区分阻塞原语因为阻塞返回还是真正的返回。在迭代器里，就需要区分两种情形并且对返回值进行不同的处理。（或者说区分 yield 和 return）。`args` 就是在定义时定义的传入的参数表。第三个括弧则用来启动这个阻塞原语。

	通常用来定义阻塞原语的 `def` 后面都会跟些东西修饰编译生成的「裸」原语，比如 `eisa/libs/async` 提供的 `async` 就可以处理绝大多数 JavaScript 库里面的回调。
	:*moe
		def async randPrintNums(n):
			def tasks = [];
			for var i in 0..n:
				tasks.push let(i) => async :>
					wait sleep (100 * Math.random())
					tracel i
			wait join tasks


:section{链接}
	 - Moescript: \githubProject
	 - 函数库说明: \page{lib/index}