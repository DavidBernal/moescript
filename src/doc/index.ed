::document{moescript}

**Moe is a new, not-very-little light Javascript-targeted language written in JavaScript.** 

You can get it from \githubProject.

:section{`Moec` compiler}
	:pre
		moec <options> input.moe
	:section{Options}	
		 - `-o <value>`, `--output <value>`: Specify the path of output file. If it is not specified, `moec` will print generated code into STDOUT.
		 - `-t <value>`，`--target <value>`: Specify the compilation target which affects global variable list. `-t least` will provide `require`、`module` and `exports` only for globals. `-t node` will provide all Node global variables.
		 - `-g <value>`，`--global <value>`: Specify a global variable, e.g. `-g document`。
		 - `-m <name>=<path>`，`--module <name>=<path>`: Map a module into a global variable, for exmaple, `-m exp=express` will map `require('express')` into the global variablr `exp` inside Moe source.

:section{Moe loader}
	The `moeDummy` makes Node possible to load `.moe` files as well as `.js`. Everything required is
	:*js
		require('moe/dummy')

:section{Overview}
	First, whitespaces plays important rule in Moe, indents means structure for example. There is nothing works like `end` or `{}` in other languages. It is not required to use `;` to terminate statements (though semiclolns still works as well), and use indentation instead of surrounding statements with `{}`. Every control block is started by a symbol like `:`, `=>` or `=`.
	:*moe
		def max(list):
			var m = list[0]
			for var i in 0..list.length:
				if list[i] > m: m = list[i]
			return m
		tracel max [5, 4, 3, 2, 1]

	Newlines **around** some symbols will be ignored so that you could write long expressions or complex literals. Unlike Python, line breaks inside parentheses, which often causes syntax errors, will not be ignored.
	:*moe
		tracel \
			1,
			2,
			3 +
			 4
			 + 5

		-- A game congi
		def gameConfig = [
			player: [
				name: "tom",
				type: Human,
				level: 1,
				weapon: sword,
				inventory: [food, food, potion, bomb]
			],
			enemy: [
				name: "Dragon",
				type: Dragon,
				level: 9
			]
		]

		// some lisp code
		def code = ['define', ['fib', 'n'],
			['cond',
			  [ [['=', 'n', '1'], '1'],
				[['=', 'n', '2'], '1'],
				['()', 
					['+', ['fib', ['-', 'n', '1']],
						['fib', ['-', 'n', '2']]]]]]]
	:*moe
		-- Wrong example: newline inside parentheses
		--	(tracel  -- here
		--		x,
		--		y,
		--		z)

:section{Objects}
	对象的直接量和数组直接量都使用方括弧 `[]`。因而，`[]` 表示空数组，空对象使用复杂些的符号 `[:]` 表示。

	除了直接量也可以使用标准库里的 `object` 函数（适合对性能要求不高、作为配置使用的大型对象）：
	:*moe
		def gameConfig = object =>
		    @player = object =>
		        @name = "tom"
		        @type = Human
		        @level = 1
		        @weapon = sword
		        @inventory = [food, food, potion, bomb]
		    @enemy = object =>
		        @name = "Dragon"
		        @type = Dragon
		        @level = 9
:section{变量（包括变不了的）}
	Moe 的变量用 `var` 或者 `def` 声明。`def` 声明出来的东西更接近常量，他们不能被再次赋值。在代码中，应当尽量使用 `def` 定义常量。他们典型的用法是这样：
	:*moe
		def printPrimes(uplimit):
			def primes = [2, 3, 5, 7];
			for var n in 2 ... uplimit:
				var composite = false
				for (var t = 0; primes[t] * primes[t] <= n; t += 1):
					if n % primes[t] == 0: 
						composite = true;
						break;
				if not composite:
					primes.push n;
					tracel n;

	变量的作用域法则完全等同 JavaScript，使用 `var` 来「局域化」变量。这和一些生成 JavaScript 的语言不同，但是对于熟悉 JavaScript 的用户来说，这样很有用。

	`def` 只能来定义一个东西，而 `var` 一次可以声明多个变量（方法：`var a, b, c, d, ..., z`，不能赋值）。`def` 和 `var` 也可用于定义对象的属性，这只相当于是一次简单赋值。
	:*moe
		def Number.prototype.times = function(f):
			for var i in 0..this: f(i)
:section{函数}
	最好用（以及最推荐）的方法是使用 `def` 定义函数。
	:*moe
		def square(x) = x * x   // 简单的函数可以这样定义

		def fill(container, liquid = "water"): // 默认参数用等号表示，只能出现在最右。
			// 使用冒号不生成 return
			tracel ("Fill " + container + " with " + liquid)

		// Y 组合子
		def Y(g) = // 在这里使用等号……
			def rec(x)(y) = g(x(x)) y
			rec(rec) // 就会在这里自动产生 return 语句
		
		//def FixedCombinator(g)(x) = g(Y(g))(x)

		// 使用 Y 组合子定义「递归」函数
		def Y fibonacci(recurse)(n) = // 多个参数表表示柯里化
			if(n <= 2): 1
			else: recurse(n - 2) + recurse(n - 1)
		
		fibonacci(5) // 5

	使用 `def` 定义函数应写下 `def`、你想定义的函数名、参数表，然后是 `:` 或者 `=`。在使用 `:` 的时候，你必须自己写 `return` 语句来指明返回值；使用 `=` 则不必要，编译器会自动把这个函数里最后一个表达式语句作为返回值。
	
	值得注意的是最后一个使用 Y 组合子制造递归函数的案例。在此处，`Y` 将后面的函数进行处理后赋值给 `fibonacci`；这里的 `Y` 只是一个普通函数，在上面定义出来。这些修饰很像 Python 里的那些。然而，使用修饰时，函数的签名可能会发生变化，增加代码的复杂性，因此在这种情况发生的时候，建议增加注释说明。在上面那个案例里，实际上发生的赋值是这样的：
	:*moe
		def fibonacci_1 = function(recurse):
			return function(n):
				return 1 if(n <= 2),
					recurse(n - 2) + recurse(n - 1)
		def fibonacci = Y(fibonacci_1)
	
	这里出现了新的关键字 `function` 以及用它定义的匿名函数。匿名函数在 JavaScript 里很常见，在 Moe 中，定义一个匿名函数值的方法相当多，最直接的就是用 `function` 关键字换掉 `def` 里写下的函数名。类似 `def` 里的情况，`function（...)` 之后也可以跟 `:` 和 `=`，两者的区别仍然是，「`=`」会自动产生 `return`，「`:`」不会。
	:*moe
		def fibonacci_2 = function(recurse)=
			function(n)=
				1 if(n <= 2),
					recurse(n - 2) + recurse(n - 1)
	
	另一种方法是使用 `:>` 或 `=>`，构造 Lambda 表达式，前接参数表，后接函数体。规律和 `function` 里的用法很相似，`:>` 必须手工写入 `return` 语句，`=>` 会自动生成 `return`。`=>` 经常用于定义一些小函数。

	:*moe
		list.map (term, index) => term * index // 没有缩进的话，Lambda 表达式会「尽可能的长」
		$(element).bind "click", (event) :>
			tracel event

	Lambda 表达式的 `:>` 和 `=>` 也可以没有参数表，作用和 `() :>` 相同。使用回调的时候这种形式会有用。
	:*moe
		def sleep(dt, f) = setTimeout(f, dt)
		sleep 1000, :>
			tracel 'Blah!'
		// 注意下面的代码和 (act) :> something 不同
		act :> something
	
	最后一种形式是用花括弧包裹住表达式，这在 DSL 里这会很常见。表达式的值就是此函数的返回值。
	:*moe
		def repeatWhile(condition, body):
			var c
			while(c = condition()):
				body(c)

		var num = 10;
		repeatWhile {num -= 1}, {|j| tracel j}

:section{调用函数}
	调用函数最直接的方法是使用圆括号，圆括号和之前的被调用函数之间**不能有空白**：
	:*moe
		def f(x, y, z) = x * y + z
		f(1, 1, 1) // 2
	
	可以使用名称参数。名称参数会汇聚起来，作为函数的最后一个实参传入。
	:*moe
		def f(config) = config.a + config.b
		f(a: 1, b: 2) // 3

	如果调用的实参表只有一项而且是使用 `{}` 的函数直接量时，可以用花括弧直接替换圆括弧：
	:*moe
		act{tracel 'Acted!'}
	
	在不混淆时，可以省略括弧，下面是一些案例。
	:*moe
		f g h a, b, c
		x y z w
		f
	分别等价于
	:*moe
		f(g(h(a, b, c)))
		x(y(z(w)))
		f  // 不产生调用
	Moe 支持的省略调用只能有「`f g h a, b, c`」这样的形式，而且省略调用和运算符不能混用（因此 `f + g h` 会产生语法错）。
	
	Moe 支持一种特殊的方法来调用函数。通过使用 `|` 符号。在此符号后写上函数也表示函数调用，竖线之前者作为此次调用的第一个参数传入。您还可以追加更多的参数，写在后面。`|` 可以有很多个，串成一长串。在计算的时候，竖线之前的东西会先计算，之后才是写在竖线后的函数，因而在最终编译生成的 JavaScript 里，可能会有临时变量和赋值出现。
	:*moe
		def tap(value, f) = f(value) then value;
		5 |tap {|x| tracel x} |{|x| x * 3} // 5
		  |tap {|x| tracel x}              // 15
		 
	JavaScript 里很常用的「链式调用」使用一个略微不同的符号 `|.`，之后接方法名。
	:*moe
		$ "selector"
			|.addClass "selected"
			|.css background: "red"
	
	两种“管道调用”可以任意组合。

	总的来说 Moe 表达式的语法是：
	:*pre
		SingleExpression
			= OperatorExpression
			| OmissionCallExpression
		OmissionCallExpression
			= Unary
			| Unary ArgumentList
			| Unary OmissionCallExpression
		PipeExpression
			= SingleExpression
			| PipeExpression PipelineTerm
		IfExpression
			= PipeExpression
			| IfExpression ifAffix
		Assignment 
			= Unary AssignmentOperator Expression
		Expression
			= Assignment
			| IfExpression

		CallItem
			= OperatorExpression
			| Unary CallItem

	:section{伪函数}
		Moe 中有几个关键字可以像函数那样「调用」，不过它们实际上作用于编译期，用来生成特殊的代码。它们是 `new`、`resend`、`do` 和 `wait`。它们称为伪函数。所有的伪函数都只能接受一个非命名参数（否则报语法错），不能单独出现（否则照样语法错）。一些伪函数还限制它们接受的「参数」必须拥有函数调用的形式，这样的伪函数也可以叫做调用修饰。

		`new` 用来构造对象：
		:*moe
			def Point(x, y):
				this.x = x
				this.y = y

			def origin = new Point 0, 0
		
		`resend` 用来向其他函数封送 `this`。在面向对象编程里，常用于调用「基类」的方法。它后面必须接一个函数调用。
		:*moe
			def Man():
				//...
			def Man::speak(something) = tracel something;

			def outof(Man) Child():
				//...
			def Child::speak(something):
				tracel "Ah!";
				tracel resend Man::speak(something)
				// 等价于 tracel Man.prototype.speak.call(this, something)
		`do` 的行为和 `resend` 很相似。`do` 后接函数调用时的行为同 `resend` 一致，但是 `do` 后面还可以接其他形式的表达式，此时 `do f` 相当于 `f.apply(this, arguments)`。

		`wait` 用于生成回调。如果某个函数里出现了 `wait`，这个函数里的所有代码生成都会受到影响，甚至它本身也会变成其他类型。`wait` 常用于异步操作中。`wait` 后面也必须接一个函数调用。
		:*moe
			def f():
				// 不需要书写 loadResource something, function(resource)...
				var resource = wait loadResource(something)
			tracel (type of f) // "object"，此时 f 是一个阻塞原语（见下文），并非普通函数。

		`wait` 有一种等价的形式，是把 `!` 插在被调用的函数之后，**之前不能有空白**，如 `loadResource! something`。

:section{回调和阻塞}
	前文已经述及，`wait` 所在的函数会变成阻塞原语。阻塞原语是一个对象，结构大致是这样：
	:*moe
		// 这样的定义……
		def obstructive(args):
			//... wait f() ...
			//... f!() ...
		// 形成这样的对象
		[build: function(schemata)(args)()]
	
	`schemata` 是一个对象，定义了一组方法（`break` 和 `return`，以后可能还会增加 `error`）来处理阻塞原语的返回值，区分阻塞原语因为阻塞返回还是真正的返回。在迭代器里，就需要区分两种情形并且对返回值进行不同的处理。（或者说区分 yield 和 return）。`args` 就是在定义时定义的传入的参数表。第三个括弧则用来启动这个阻塞原语。

	通常用来定义阻塞原语的 `def` 后面都会跟些东西修饰编译生成的「裸」原语，比如 `eisa/libs/async` 提供的 `async` 就可以处理绝大多数 JavaScript 库里面的回调。
	:*moe
		def async randPrintNums(n):
			def tasks = [];
			for var i in 0..n:
				tasks.push let(i) => async :>
					wait sleep (100 * Math.random())
					tracel i
			wait join tasks


:section{链接}
	 - Moescript: \githubProject
	 - 函数库说明: \page{lib/index}