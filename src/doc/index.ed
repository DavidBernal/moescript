::document{moescript}

**Moe is a new, not-very-little light Javascript-targeted language written in JavaScript.** 

You can get it from \githubProject.

:section{`Moec` compiler}
	:pre
		moec <options> input.moe
	:section{Options}	
		 - `-o <value>`, `--output <value>`: Specify the path of output file. If it is not specified, `moec` will print generated code into STDOUT.
		 - `-t <value>`，`--target <value>`: Specify the compilation target which affects global variable list. `-t least` will provide `require`、`module` and `exports` only for globals. `-t node` will provide all Node global variables.
		 - `-g <value>`，`--global <value>`: Specify a global variable, e.g. `-g document`。
		 - `-m <name>=<path>`，`--module <name>=<path>`: Map a module into a global variable, for exmaple, `-m exp=express` will map `require('express')` into the global variablr `exp` inside Moe source.

:section{Moe loader}
	The `moeDummy` makes Node possible to load `.moe` files as well as `.js`. Everything required is
	:*js
		require('moe/dummy')

:section{Overview}
	First, whitespaces plays important rule in Moe, indents means structure for example. There is nothing works like `end` or `{}` in other languages. It is not required to use `;` to terminate statements (though semiclolns still works as well), and use indentation instead of surrounding statements with `{}`. Every control block is started by a symbol like `:`, `=>` or `=`, then one **unindented** statement, or a indented statement block.
	|moe
		def max(list):
			var m = list[0]
			for var i in 0..list.length:
				if list[i] > m: m = list[i]
			return m
		tracel max [5, 4, 3, 2, 1]

	Newlines **around** some symbols will be ignored so that you could write long expressions or complex literals. Unlike Python, line breaks inside parentheses, which often causes syntax errors, will not be ignored.
	|moe
		tracel \
			1,
			2,
			3 +
			 4
			 + 5

		-- A game congi
		def gameConfig = [
			player: [
				name: "tom",
				type: Human,
				level: 1,
				weapon: sword,
				inventory: [food, food, potion, bomb]
			],
			enemy: [
				name: "Dragon",
				type: Dragon,
				level: 9
			]
		]

		// some lisp code
		def code = ['define', ['fib', 'n'],
			['cond',
			  [ [['=', 'n', '1'], '1'],
				[['=', 'n', '2'], '1'],
				['()', 
					['+', ['fib', ['-', 'n', '1']],
						['fib', ['-', 'n', '2']]]]]]]
	|moe
		-- Wrong example: newline inside parentheses
		--	(tracel  -- here
		--		x,
		--		y,
		--		z)

:section{Variables (and immutable ones)}
	Variables in Moe is defined by `var` or `def`. "Variables" defined by `def` is actually a constant, which means it is impossible make any assignment to it. Scopes rule is exactly same as JavaScript, `var` and `def` **shadows** external variables.
	|moe
		var outer = 1
		var x = 2
		def f = function():
			var inner = 3
			outer = 4
			var x = 5
			tracel inner  -- 3
			tracel outer  -- 4
			tracel x      -- 5
		f()
		tracel outer      -- 4
		tracel x          -- 2

	`def` can only define one thing once, with `var` can declares multiple variables without initialization. However, you are able to use `def` for defining properties, which is useful processing objects. In this situation, `def` is only a simple assignment.
	|moe
		def Number.prototype.times = function(f):
			for var i in 0..this: f(i)

:section{Functions}
	The most recommended way to define a function is using `def`. Add argument list after the function name, then a `:` or `=`, then the function body.

	Function bodies started by `=` will **generate `return` statements automatically**, means its last expression executed will become its return value. Therefore, it is not required to use `return` statements. On the contraty, `:`-bodies won't. You must use `return` statements explicitly to specify its return value, or the function will simply return `undefined`, like what JavaScript acts.

	Functions may also have default values for arguments. Override the default value by passing an argument.

	|moe
		// Define a simple function
		-- function square: calculate square of a number
		-- square(x <- Number) <- Number
		def square(x) = x * x

		// A procedure.
		-- function printPrimes: print all prime numbers not greater than an uplimit specified
		-- printPrimes(uplimit <- Number)
		def printPrimes(uplimit):
			def primes = [2, 3, 5, 7];
			for var n in 2 ... uplimit:
				var composite = false
				for (var t = 0; primes[t] * primes[t] <= n; t += 1):
					if n % primes[t] == 0: 
						composite = true;
						break;
				if not composite:
					primes.push n;
					tracel n;

		// Parameters with default value
		def fill(container, liquid = "water"):
			tracel ("Fill " + container + " with " + liquid)

		-- function Y: Fixed point combinator
		-- Y(g <- Function) <- Function
		--     which Y(g)(x) = g(Y(g))(x)
		def Y(g) =
			// use "=" here...
			def rec(x)(y) = g(x(x)) y
			rec(rec) // ...means this value will be returned.
		
		// Define recursive function using Y
		def Y fibonacci(recurse)(n) =
			// Multiple argument lists means currying
			if(n <= 2): 1
			else: recurse(n - 2) + recurse(n - 1)
		
		fibonacci(5) // 5
	
	There is a notable example using the `Y` combinator. Expressions like `Y` after `def` is a **modifer**, which is useful in defining wrapped functions, for example, recursive functions produced by `Y`. Here, `fibonacci` is actually:
	|moe
		def fibonacci_1 = function(recurse):
			return function(n):
				return 1 if(n <= 2),
					recurse(n - 2) + recurse(n - 1)
		def fibonacci = Y(fibonacci_1)
	
	No-name functions can be defined using `function`. Like what we did in `def`, you can simply replace that function name by `function`. In the same matter, `=` for automatic generated `return`s, `:` for manual.
	|moe
		def fibonacci_2 = function(recurse)=
			function(n)=
				1 if(n <= 2),
					recurse(n - 2) + recurse(n - 1)
	
	Another way, called **Lambdas**, is using an optional list of parameters, an arrow(`:>` or `=>`), and the function body. Unindented Lambdas will extend all the way to the right as long aspossible. The `=`-`:` rule still rules here.
	|moe
		list.map (term, index) => term * index
		$(element).bind "click", (event) :>
			tracel event

		def sleep(dt, f) = setTimeout(f, dt)
		sleep 1000, :>
			tracel 'Blah!'
		// Note: different from (act) :> something
		act :> something
	
	The final form is wrapping **one** expression using `{}`. The wrapped expression will be the return value. Arguments are writtern inside the brackets, and wrapped by `|`'s. This is called **Delaied expression**.
	|moe
		def repeatWhile(condition, body):
			var c
			while(c = condition()):
				body(c)

		var num = 10;
		repeatWhile {num -= 1}, {|j| tracel j}

:section{Objects}
	Both object literals and array literals uses `[]`. Therefore, empty objects should use `[:]` while `[]` means empty array. Keywords can appear inside object literals without quoting.
	|moe
		def actions = [
			if: ((cond, fThen, fElse) => fThen() if(cond), fElse())
		]

	You can also use `object` function provided in standard libary for large objects, especially configs.
	|moe
		-- function object: creates object using a constructor with an optional prototype.
		-- object(oPrototype, fConstruct) <- Derives(oPrototype)
		-- object(fConstruct) <- Object

		def gameConfig = object =>
		    @player = object =>
		        @name = "tom"
		        @type = Human
		        @level = 1
		        @weapon = sword
		        @inventory = [food, food, potion, bomb]
		    @enemy = object =>
		        @name = "Dragon"
		        @type = Dragon
		        @level = 9

:section{Calling functions}
	The most direct way to call a function is using brackets(`()`). Note that there **must not** be any space between the function and the brackets. If there is only one argument, and it is a delaied expression (`{expr}`), the `()` can be omitted.
	|moe
		def f(x, y, z) = x * y + z
		f(1, 1, 1) // 2

		def act(f) = f()
		act{tracel 'blah!'} // short for act({tracel 'blah!'})
	
	You can use named arguments. All named arguments will be accumulated into an object literal passed into the function as the last argument.
	|moe
		def f(config) = config.a + config.b
		f(a: 1, b: 2) // 3
	
	Brackets can be omitted when it is not aminigous, for example:
	|moe
		f g h a, b, c   // = f(g(h(a, b, v)))
		x y z w         // = x(y(z(w)))
		f               // = f; No invocation.
		square x * x    // = square(x) * x; Not square(x * x)

	Omissioned calls has a lower priority than calls using brackets. Only the "`f g h a, b, c`" is supported. You can also use omissioned calls with operators togther. Omissioned calls has a higher priority than operators, therefore, `square x * x` means `square(x) * x`.
	
	Moe supports a special calling method, by using "Pipe sign" `|`, which has an extremely low priority. The calling form `a |f b, c, d` means `f(a, b, c, d)`, or more strictly, `seq T = a, f(T, b, c, d)` due to `a` will be evaluated **before** `f`. `a |f` means `f(a)`, with reversed evaluation order, `a` before `f`.
	|moe
		def tap(value, f) = seq f(value), value
		5 |tap {|x| tracel x}              // 5
		  |{|x| x * 3}
		  |tap {|x| tracel x}              // 15

	Chain calls, usually used in JavaScript, is supported by a slightly modified pipe `|.`. Add the method name after the pipe-dot sign. Both pipe forms can be combined in any order.
	|moe
		$ "selector"
		  |.addClass "selected"
		  |.css background: "red"
	
	:section{Call wrappers}
		There are some special keywords which can be called like normal function in Moe, called Call Wrappers, used to generate special codes, including object creation, prototype resending, or create "wait" calls used by asynchronous functions.

		Creating objects using `new`.
		|moe
			def Point(x, y):
				this.x = x
				this.y = y

			def origin = new Point 0, 0
		
		`resend` 用来向其他函数封送 `this`。在面向对象编程里，常用于调用「基类」的方法。它后面必须接一个函数调用。
		|moe
			def Man():
				//...
			def Man::speak(something) = tracel something;

			def outof(Man) Child():
				//...
			def Child::speak(something):
				tracel "Ah!";
				tracel resend Man::speak(something)
				// 等价于 tracel Man.prototype.speak.call(this, something)
		`do` 的行为和 `resend` 很相似。`do` 后接函数调用时的行为同 `resend` 一致，但是 `do` 后面还可以接其他形式的表达式，此时 `do f` 相当于 `f.apply(this, arguments)`。

		`wait` 用于生成回调。如果某个函数里出现了 `wait`，这个函数里的所有代码生成都会受到影响，甚至它本身也会变成其他类型。`wait` 常用于异步操作中。`wait` 后面也必须接一个函数调用。
		|moe
			def f():
				// 不需要书写 loadResource something, function(resource)...
				var resource = wait loadResource(something)
			tracel (type of f) // "object"，此时 f 是一个阻塞原语（见下文），并非普通函数。

		`wait` 有一种等价的形式，是把 `!` 插在被调用的函数之后，**之前不能有空白**，如 `loadResource! something`。

:section{回调和阻塞}
	前文已经述及，`wait` 所在的函数会变成阻塞原语。阻塞原语是一个对象，结构大致是这样：
	|moe
		// 这样的定义……
		def obstructive(args):
			//... wait f() ...
			//... f!() ...
		// 形成这样的对象
		[build: function(schemata)(args)()]
	
	`schemata` 是一个对象，定义了一组方法（`break` 和 `return`，以后可能还会增加 `error`）来处理阻塞原语的返回值，区分阻塞原语因为阻塞返回还是真正的返回。在迭代器里，就需要区分两种情形并且对返回值进行不同的处理。（或者说区分 yield 和 return）。`args` 就是在定义时定义的传入的参数表。第三个括弧则用来启动这个阻塞原语。

	通常用来定义阻塞原语的 `def` 后面都会跟些东西修饰编译生成的「裸」原语，比如 `eisa/libs/async` 提供的 `async` 就可以处理绝大多数 JavaScript 库里面的回调。
	|moe
		def async randPrintNums(n):
		    def tasks = [];
		    for var i in 0..n:
		        tasks.push async :>
		            wait sleep (100 * Math.random())
		            tracel index
		        where index = i;
		    wait join tasks

		randPrintNums 100

:section{链接}
	 - Moescript: \githubProject
	 - 函数库说明: \page{lib/index}